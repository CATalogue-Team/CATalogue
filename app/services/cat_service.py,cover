> from typing import List, Optional, Type, Dict, Any, Union
> from datetime import datetime, timezone
> from sqlalchemy.orm import Query
> from .. import db
> from ..models import Cat, User, CatImage
> from werkzeug.datastructures import FileStorage
> from werkzeug.utils import secure_filename
> import os
> from flask import current_app
> from .base_service import BaseService
  
> class CatService(BaseService):
>     """猫咪信息服务层"""
>     def __init__(self, db):
>         super().__init__(db)
          
>     model = Cat  # 定义模型类
      
>     def get(self, id_or_model: Union[int, Type[Cat]], model: Optional[Type[Cat]] = None) -> Optional[Cat]:
>         """获取单个猫咪信息
>         参数:
>             id_or_model: 猫咪ID或模型类
>             model: 可选模型类，默认为Cat
>         返回:
>             猫咪对象或None
>         """
!         if isinstance(id_or_model, int):
!             return super().get(model or self.model, id_or_model)
!         elif isinstance(id_or_model, type) and issubclass(id_or_model, Cat):
              # 返回实际查询结果
!             return db.session.query(id_or_model).first()
!         raise ValueError("参数必须是猫咪ID或Cat类")
      
>     def create_cat(self, user_id: int, **kwargs) -> Cat:
>         """创建猫咪信息"""
!         if not user_id:
!             raise ValueError("user_id是必填字段")
              
          # 检查名称是否已存在
!         if 'name' in kwargs and db.session.query(Cat).filter_by(name=kwargs['name']).first():
!             raise ValueError(f"猫咪名称'{kwargs['name']}'已存在")
              
          # 验证年龄范围
!         if 'age' in kwargs and (kwargs['age'] < 0 or kwargs['age'] > 30):
!             raise ValueError("猫咪年龄必须在0-30岁之间")
              
!         try:
!             cat = Cat(
!                 user_id=user_id,
!                 created_at=datetime.now(timezone.utc),
!                 updated_at=datetime.now(timezone.utc),
!                 **kwargs
!             )
!             db.session.add(cat)
!             db.session.commit()
!             return cat
!         except Exception as e:
!             db.session.rollback()
!             current_app.logger.error(f"创建猫咪失败: {str(e)}")
!             raise
  
>     def _handle_images(self, cat_id: int, images: List[FileStorage]) -> None:
>         """处理猫咪图片上传"""
!         if not images:
!             return
  
!         max_size = current_app.config.get('MAX_IMAGE_SIZE', 5 * 1024 * 1024)  # 默认5MB
          
!         try:
!             for i, image in enumerate(images):
                  # 检查文件大小和类型
!                 image.seek(0, 2)  # 移动到文件末尾
!                 file_size = image.tell()
!                 image.seek(0)  # 重置文件指针
                  
!                 if file_size > max_size:
!                     raise ValueError(f"图片大小超过限制({max_size/1024/1024:.1f}MB)")
!                 if not image.content_type.startswith('image/'):
!                     raise ValueError("只允许上传图片文件")
  
!                 filename = secure_filename(image.filename or f"cat_{cat_id}_{i}.jpg")
!                 upload_folder = current_app.config['UPLOAD_FOLDER']
!                 save_path = os.path.join(upload_folder, filename)
!                 image.save(save_path)
  
!                 db.session.add(CatImage(
!                     url=f"/static/uploads/{filename}",
!                     is_primary=(i == 0),
!                     cat_id=cat_id
!                 ))
              
!             db.session.commit()
!         except Exception as e:
!             db.session.rollback()
!             raise
  
>     def search(self, **kwargs) -> List[Cat]:
>         """搜索猫咪"""
!         query = db.session.query(Cat).order_by(Cat.updated_at.desc())
          
          # 添加按名称搜索
!         if 'name' in kwargs:
!             query = query.filter(Cat.name.ilike(f"%{kwargs['name']}%"))
          
!         if 'breed' in kwargs:
!             query = query.filter(Cat.breed.ilike(f"%{kwargs['breed']}%"))
!         if 'min_age' in kwargs:
!             query = query.filter(Cat.age >= kwargs['min_age'])
!         if 'max_age' in kwargs:
!             query = query.filter(Cat.age <= kwargs['max_age'])
!         if 'page' in kwargs and 'per_page' in kwargs:
!             query = query.offset((kwargs['page'] - 1) * kwargs['per_page']) \
!                          .limit(kwargs['per_page'])
                             
!         return query.all()
  
>     def update_cat(self, cat_id: int, user_id: Optional[int] = None, **kwargs) -> Optional[Cat]:
>         """更新猫咪信息"""
!         cat = self.get(cat_id)
!         if not cat:
!             raise ValueError(f"猫咪ID {cat_id} 不存在")
              
!         if user_id and cat.user_id != user_id:
!             raise PermissionError("无权修改其他用户的猫咪信息")
              
!         try:
!             for key, value in kwargs.items():
!                 setattr(cat, key, value)
!             cat.updated_at = datetime.now(timezone.utc)
!             db.session.commit()
!             return cat
!         except Exception as e:
!             db.session.rollback()
!             current_app.logger.error(f"更新猫咪失败: {str(e)}")
!             raise
  
>     def delete_cat(self, cat_id: int, user_id: Optional[int] = None) -> bool:
>         """删除猫咪信息"""
!         cat = self.get(cat_id)
!         if not cat:
!             raise ValueError(f"猫咪ID {cat_id} 不存在")
              
!         if user_id and cat.user_id != user_id:
!             return False
              
!         try:
!             db.session.delete(cat)
!             db.session.commit()
!             return True
!         except Exception as e:
!             db.session.rollback()
!             current_app.logger.error(f"删除猫咪失败: {str(e)}")
!             return False
  
>     def batch_create(self, cats_data: List[Dict[str, Any]], user_id: int) -> List[Optional[Cat]]:
>         """批量创建猫咪记录
>         参数:
>             cats_data: 猫咪数据列表
>             user_id: 用户ID
>         返回:
>             返回猫咪对象列表，成功创建返回Cat对象，失败返回None
>             全部失败时抛出异常
  
>         示例:
>             >>> # 全部成功
>             >>> result = service.batch_create([{...}, {...}], 1)
>             >>> all(isinstance(cat, Cat) for cat in result)  # True
  
>             >>> # 部分成功
>             >>> result = service.batch_create([good_data, bad_data], 1)
>             >>> result[0] is not None and result[1] is None  # True
  
>             >>> # 全部失败
>             >>> try:
>             ...     service.batch_create([bad_data1, bad_data2], 1)
>             ... except Exception as e:
>             ...     print(str(e))
>         """
!         success = []
!         failed = []
          
!         for cat_data in cats_data:
!             try:
!                 if not cat_data.get('name'):
!                     raise ValueError("猫咪名称不能为空")
!                 cat = self.create_cat(user_id=user_id, **cat_data)
!                 success.append(cat)
!             except Exception as e:
!                 failed.append({
!                     'data': cat_data,
!                     'error': str(e)
!                 })
!                 db.session.rollback()
                  # 确保不返回任何Cat对象
!                 success.append(None)
          
!         try:
!             if not success and failed:
!                 current_app.logger.error(f"批量创建全部失败: {failed[0]['error']}")
!                 raise Exception(f"批量创建全部失败: {failed[0]['error']}")
              
              # 记录部分失败的日志
!             if failed:
!                 for fail in failed:
!                     current_app.logger.error(f"创建猫咪失败: {fail['error']}")
              
!             db.session.commit()
!         except Exception as e:
!             db.session.rollback()
!             current_app.logger.error(f"创建猫咪失败: {str(e)}")
!             raise
          
          # 构建返回列表，成功项为Cat对象，失败项为None
!         result = []
!         for cat_data in cats_data:
              # 检查是否有对应的成功记录
!             matched_cat = None
!             for cat in success:
!                 if cat and cat.name == cat_data.get('name'):
!                     matched_cat = cat
!                     break
!             result.append(matched_cat)
!         return result
  
>     def batch_update(self, update_data: Dict[int, Dict[str, Any]]) -> List[Cat]:
>         """批量更新猫咪记录
>         参数:
>             update_data: 更新数据字典，key为猫咪ID，value为更新字段
>         返回:
>             更新后的猫咪列表
>         """
!         results = []
!         try:
!             for cat_id, data in update_data.items():
!                 cat = self.update_cat(cat_id, **data)
!                 if cat:
!                     results.append(cat)
!             return results
!         except Exception as e:
!             db.session.rollback()
!             current_app.logger.error(f"批量更新猫咪失败: {str(e)}")
!             raise
  
>     def get_cat_stats(self) -> Dict[str, Any]:
>         """获取猫咪统计信息"""
>         stats = {
>             'total': self.db.session.query(Cat).count(),
>             'by_breed': dict(self.db.session.query(Cat.breed, db.func.count(Cat.id))
>                             .group_by(Cat.breed).all()),
>             'by_adoption': {
>                 'adopted': self.db.session.query(Cat).filter(Cat.is_adopted == True).count(),
>                 'not_adopted': self.db.session.query(Cat).filter(Cat.is_adopted == False).count()
>             },
>             'age_distribution': {
>                 'kitten': self.db.session.query(Cat).filter(Cat.age == 0).count(),
>                 'young': self.db.session.query(Cat).filter(Cat.age.between(1, 2)).count(),
>                 'adult': self.db.session.query(Cat).filter(Cat.age.between(3, 6)).count(),
>                 'senior': self.db.session.query(Cat).filter(Cat.age >= 7).count()
>             }
>         }
>         return stats
  
>     def validate_image_urls(self) -> List[tuple]:
>         """校验并修复图片URL"""
!         invalid_urls = []
!         images = db.session.query(CatImage).all()
          
!         for image in images:
!             if image.url and '/static/uploads//static/uploads/' in image.url:
!                 original = image.url
!                 image.url = image.url.replace('/static/uploads//static/uploads/', '/static/uploads/')
!                 invalid_urls.append((original, image.url))
          
!         db.session.commit()
!         return invalid_urls
